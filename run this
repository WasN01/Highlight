local StrToNumber = tonumber;
local Byte = string.byte;
local Char = string.char;
local Sub = string.sub;
local Subg = string.gsub;
local Rep = string.rep;
local Concat = table.concat;
local Insert = table.insert;
local LDExp = math.ldexp;
local GetFEnv = getfenv or function()
return _ENV;
end;
local Setmetatable = setmetatable;
local PCall = pcall;
local Select = select;
local Unpack = unpack or table.unpack;
local ToNumber = tonumber;
local function VMCall(ByteString, vmenv, ...)
local DIP = 1;
local repeatNext;
ByteString = Subg(Sub(ByteString, 5), "..", function(byte)
if (Byte(byte, 2) == 81) then
repeatNext = StrToNumber(Sub(byte, 1, 1));
return "";
else
local a = Char(StrToNumber(byte, 16));
if repeatNext then
local b = Rep(a, repeatNext);
repeatNext = nil;
return b;
else
return a;
end
end
end);
local function gBit(Bit, Start, End)
if End then
local Res = (Bit / (2 ^ (Start - 1))) % (2 ^ (((End - 1) - (Start - 1)) + 1));
return Res - (Res % 1);
else
local Plc = 2 ^ (Start - 1);
return (((Bit % (Plc + Plc)) >= Plc) and 1) or 0;
end
end
local function gBits8()
local a = Byte(ByteString, DIP, DIP);
DIP = DIP + 1;
return a;
end
local function gBits16()
local a, b = Byte(ByteString, DIP, DIP + 2);
DIP = DIP + 2;
return (b * 256) + a;
end
local function gBits32()
local a, b, c, d = Byte(ByteString, DIP, DIP + 3);
DIP = DIP + 4;
return (d * 16777216) + (c * 65536) + (b * 256) + a;
end
local function gFloat()
local Left = gBits32();
local Right = gBits32();
local IsNormal = 1;
local Mantissa = (gBit(Right, 1, 20) * (2 ^ 32)) + Left;
local Exponent = gBit(Right, 21, 31);
local Sign = ((gBit(Right, 32) == 1) and -1) or 1;
if (Exponent == 0) then
if (Mantissa == 0) then
return Sign * 0;
else
Exponent = 1;
IsNormal = 0;
end
elseif (Exponent == 2047) then
return ((Mantissa == 0) and (Sign * (1 / 0))) or (Sign * NaN);
end
return LDExp(Sign, Exponent - 1023) * (IsNormal + (Mantissa / (2 ^ 52)));
end
local function gString(Len)
local Str;
if not Len then
Len = gBits32();
if (Len == 0) then
return "";
end
end
Str = Sub(ByteString, DIP, (DIP + Len) - 1);
DIP = DIP + Len;
local FStr = {};
for Idx = 1, #Str do
FStr[Idx] = Char(Byte(Sub(Str, Idx, Idx)));
end
return Concat(FStr);
end
local gInt = gBits32;
local function _R(...)
return {...}, Select("#", ...);
end
local function Deserialize()
local Instrs = {};
local Functions = {};
local Lines = {};
local Chunk = {Instrs,Functions,nil,Lines};
local ConstCount = gBits32();
local Consts = {};
for Idx = 1, ConstCount do
local Type = gBits8();
local Cons;
if (Type == 1) then
Cons = gBits8() ~= 0;
elseif (Type == 2) then
Cons = gFloat();
elseif (Type == 3) then
Cons = gString();
end
Consts[Idx] = Cons;
end
Chunk[3] = gBits8();
for Idx = 1, gBits32() do
local Descriptor = gBits8();
if (gBit(Descriptor, 1, 1) == 0) then
local Type = gBit(Descriptor, 2, 3);
local Mask = gBit(Descriptor, 4, 6);
local Inst = {gBits16(),gBits16(),nil,nil};
if (Type == 0) then
Inst[3] = gBits16();
Inst[4] = gBits16();
elseif (Type == 1) then
Inst[3] = gBits32();
elseif (Type == 2) then
Inst[3] = gBits32() - (2 ^ 16);
elseif (Type == 3) then
Inst[3] = gBits32() - (2 ^ 16);
Inst[4] = gBits16();
end
if (gBit(Mask, 1, 1) == 1) then
Inst[2] = Consts[Inst[2]];
end
if (gBit(Mask, 2, 2) == 1) then
Inst[3] = Consts[Inst[3]];
end
if (gBit(Mask, 3, 3) == 1) then
Inst[4] = Consts[Inst[4]];
end
Instrs[Idx] = Inst;
end
end
for Idx = 1, gBits32() do
Functions[Idx - 1] = Deserialize();
end
return Chunk;
end
local function Wrap(Chunk, Upvalues, Env)
local Instr = Chunk[1];
local Proto = Chunk[2];
local Params = Chunk[3];
return function(...)
local Instr = Instr;
local Proto = Proto;
local Params = Params;
local _R = _R;
local VIP = 1;
local Top = -1;
local Vararg = {};
local Args = {...};
local PCount = Select("#", ...) - 1;
local Lupvals = {};
local Stk = {};
for Idx = 0, PCount do
if (Idx >= Params) then
Vararg[Idx - Params] = Args[Idx + 1];
else
Stk[Idx] = Args[Idx + 1];
end
end
local Varargsz = (PCount - Params) + 1;
local Inst;
local Enum;
while true do
Inst = Instr[VIP];
Enum = Inst[1];
if (Enum <= 56) then
if (Enum <= 27) then
if (Enum <= 13) then
if (Enum <= 6) then
if (Enum <= 2) then
if (Enum <= 0) then
Stk[Inst[2]] = Stk[Inst[3]] % Stk[Inst[4]];
elseif (Enum == 1) then
Upvalues[Inst[3]] = Stk[Inst[2]];
else
local A = Inst[2];
local T = Stk[A];
for Idx = A + 1, Top do
Insert(T, Stk[Idx]);
end
end
elseif (Enum <= 4) then
if (Enum > 3) then
Stk[Inst[2]] = not Stk[Inst[3]];
else
local A = Inst[2];
local Results, Limit = R(Stk[A](Unpack(Stk, A + 1, Inst[3])));
Top = (Limit + A) - 1;
local Edx = 0;
for Idx = A, Top do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum == 5) then
Stk[Inst[2]][Stk[Inst[3]]] = Inst[4];
else
local A = Inst[2];
Stk[A](Stk[A + 1]);
end
elseif (Enum <= 9) then
if (Enum <= 7) then
local A = Inst[2];
Stk[A] = Stk[A](Stk[A + 1]);
elseif (Enum == 8) then
Stk[Inst[2]] = Stk[Inst[3]];
else
do
return;
end
end
elseif (Enum <= 11) then
if (Enum == 10) then
Stk[Inst[2]] = Inst[3];
else
local A = Inst[2];
local C = Inst[4];
local CB = A + 2;
local Result = {Stk[A](Stk[A + 1], Stk[CB])};
for Idx = 1, C do
Stk[CB + Idx] = Result[Idx];
end
local R = Result[1];
if R then
Stk[CB] = R;
VIP = Inst[3];
else
VIP = VIP + 1;
end
end
elseif (Enum > 12) then
Stk[Inst[2]] = #Stk[Inst[3]];
elseif not Stk[Inst[2]] then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum <= 20) then
if (Enum <= 16) then
if (Enum <= 14) then
Stk[Inst[2]] = Stk[Inst[3]] - Stk[Inst[4]];
elseif (Enum == 15) then
local A = Inst[2];
local Results = {Stk[A](Unpack(Stk, A + 1, Inst[3]))};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
else
local A = Inst[2];
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3]));
end
elseif (Enum <= 18) then
if (Enum == 17) then
local B = Inst[3];
local K = Stk[B];
for Idx = B + 1, Inst[4] do
K = K .. Stk[Idx];
end
Stk[Inst[2]] = K;
else
local A = Inst[2];
local Results, Limit = R(Stk[A](Stk[A + 1]));
Top = (Limit + A) - 1;
local Edx = 0;
for Idx = A, Top do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum == 19) then
Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];
else
local A = Inst[2];
local Cls = {};
for Idx = 1, #Lupvals do
local List = Lupvals[Idx];
for Idz = 0, #List do
local Upv = List[Idz];
local NStk = Upv[1];
local DIP = Upv[2];
if ((NStk == Stk) and (DIP >= A)) then
Cls[DIP] = NStk[DIP];
Upv[1] = Cls;
end
end
end
end
elseif (Enum <= 23) then
if (Enum <= 21) then
do
return;
end
elseif (Enum > 22) then
local A = Inst[2];
do
return Unpack(Stk, A, Top);
end
else
local B = Stk[Inst[4]];
if B then
VIP = VIP + 1;
else
Stk[Inst[2]] = B;
VIP = Inst[3];
end
end
elseif (Enum <= 25) then
if (Enum == 24) then
local B = Inst[3];
local K = Stk[B];
for Idx = B + 1, Inst[4] do
K = K .. Stk[Idx];
end
Stk[Inst[2]] = K;
else
Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];
end
elseif (Enum == 26) then
Stk[Inst[2]] = Wrap(Proto[Inst[3]], nil, Env);
else
local A = Inst[2];
local T = Stk[A];
for Idx = A + 1, Inst[3] do
Insert(T, Stk[Idx]);
end
end
elseif (Enum <= 41) then
if (Enum <= 34) then
if (Enum <= 30) then
if (Enum <= 28) then
Stk[Inst[2]] = Inst[3] ~= 0;
elseif (Enum == 29) then
Stk[Inst[2]] = Stk[Inst[3]] * Stk[Inst[4]];
else
Stk[Inst[2]] = {};
end
elseif (Enum <= 32) then
if (Enum == 31) then
Stk[Inst[2]] = Stk[Inst[3]] * Stk[Inst[4]];
else
local B = Stk[Inst[4]];
if B then
VIP = VIP + 1;
else
Stk[Inst[2]] = B;
VIP = Inst[3];
end
end
elseif (Enum > 33) then
VIP = Inst[3];
else
local A = Inst[2];
Stk[A](Unpack(Stk, A + 1, Top));
end
elseif (Enum <= 37) then
if (Enum <= 35) then
local A = Inst[2];
local Results = {Stk[A](Unpack(Stk, A + 1, Top))};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
elseif (Enum == 36) then
do
return Stk[Inst[2]];
end
else
Stk[Inst[2]] = Stk[Inst[3]] / Stk[Inst[4]];
end
elseif (Enum <= 39) then
if (Enum > 38) then
Stk[Inst[2]] = Inst[3];
else
local B = Stk[Inst[4]];
if not B then
VIP = VIP + 1;
else
Stk[Inst[2]] = B;
VIP = Inst[3];
end
end
elseif (Enum > 40) then
Upvalues[Inst[3]] = Stk[Inst[2]];
else
local A = Inst[2];
local Results = {Stk[A](Unpack(Stk, A + 1, Top))};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum <= 48) then
if (Enum <= 44) then
if (Enum <= 42) then
Stk[Inst[2]] = Stk[Inst[3]][Stk[Inst[4]]];
elseif (Enum > 43) then
Stk[Inst[2]] = Inst[3] ~= 0;
else
Stk[Inst[2]][Stk[Inst[3]]] = Stk[Inst[4]];
end
elseif (Enum <= 46) then
if (Enum > 45) then
if (Inst[2] <= Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
local A = Inst[2];
Stk[A] = StkA;
end
elseif (Enum > 47) then
Stk[Inst[2]][Inst[3]] = Stk[Inst[4]];
else
do
return Stk[Inst[2]];
end
end
elseif (Enum <= 52) then
if (Enum <= 50) then
if (Enum > 49) then
Stk[Inst[2]] = #Stk[Inst[3]];
elseif (Stk[Inst[2]] ~= Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum > 51) then
local A = Inst[2];
local Results, Limit = R(Stk[A](Stk[A + 1]));
Top = (Limit + A) - 1;
local Edx = 0;
for Idx = A, Top do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
else
local A = Inst[2];
local T = Stk[A];
for Idx = A + 1, Top do
Insert(T, Stk[Idx]);
end
end
elseif (Enum <= 54) then
if (Enum > 53) then
if Stk[Inst[2]] then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
local A = Inst[2];
local Results = {Stk[A](Unpack(Stk, A + 1, Inst[3]))};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum == 55) then
local A = Inst[2];
local Results, Limit = R(Stk[A](Unpack(Stk, A + 1, Inst[3])));
Top = (Limit + A) - 1;
local Edx = 0;
for Idx = A, Top do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
else
Stk[Inst[2]][Stk[Inst[3]]] = Inst[4];
end
elseif (Enum <= 84) then
if (Enum <= 70) then
if (Enum <= 63) then
if (Enum <= 59) then
if (Enum <= 57) then
StkInst[2];
elseif (Enum > 58) then
Stk[Inst[2]] = Stk[Inst[3]][Stk[Inst[4]]];
else
local A = Inst[2];
Stk[A] = Stk[A](Stk[A + 1]);
end
elseif (Enum <= 61) then
if (Enum > 60) then
Stk[Inst[2]] = Env[Inst[3]];
else
local A = Inst[2];
local Results = {Stk[A](Stk[A + 1])};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum == 62) then
Stk[Inst[2]] = Stk[Inst[3]];
else
StkInst[2];
end
elseif (Enum <= 66) then
if (Enum <= 64) then
Stk[Inst[2]] = Stk[Inst[3]] / Stk[Inst[4]];
elseif (Enum > 65) then
Stk[Inst[2]] = -Stk[Inst[3]];
elseif (Stk[Inst[2]] == Inst[4]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum <= 68) then
if (Enum == 67) then
if Stk[Inst[2]] then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
local A = Inst[2];
Stk[A](Unpack(Stk, A + 1, Top));
end
elseif (Enum == 69) then
local A = Inst[2];
local C = Inst[4];
local CB = A + 2;
local Result = {Stk[A](Stk[A + 1], Stk[CB])};
for Idx = 1, C do
Stk[CB + Idx] = Result[Idx];
end
local R = Result[1];
if R then
Stk[CB] = R;
VIP = Inst[3];
else
VIP = VIP + 1;
end
else
Stk[Inst[2]][Stk[Inst[3]]] = Stk[Inst[4]];
end
elseif (Enum <= 77) then
if (Enum <= 73) then
if (Enum <= 71) then
Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];
elseif (Enum == 72) then
if (Stk[Inst[2]] == Inst[4]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
Stk[Inst[2]][Inst[3]] = Inst[4];
end
elseif (Enum <= 75) then
if (Enum == 74) then
Stk[Inst[2]] = Stk[Inst[3]] + Inst[4];
elseif (Inst[2] <= Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum == 76) then
local A = Inst[2];
local B = Stk[Inst[3]];
Stk[A + 1] = B;
Stk[A] = B[Inst[4]];
else
local A = Inst[2];
Stk[A](Unpack(Stk, A + 1, Inst[3]));
end
elseif (Enum <= 80) then
if (Enum <= 78) then
Stk[Inst[2]] = Stk[Inst[3]] - Stk[Inst[4]];
elseif (Enum > 79) then
Stk[Inst[2]] = Stk[Inst[3]] + Stk[Inst[4]];
else
Stk[Inst[2]] = Upvalues[Inst[3]];
end
elseif (Enum <= 82) then
if (Enum > 81) then
if not Stk[Inst[2]] then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
local A = Inst[2];
local Results = {Stk[A](Stk[A + 1])};
local Edx = 0;
for Idx = A, Inst[4] do
Edx = Edx + 1;
Stk[Idx] = Results[Edx];
end
end
elseif (Enum > 83) then
if (Stk[Inst[2]] < Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
else
local A = Inst[2];
Stk[A](Unpack(Stk, A + 1, Inst[3]));
end
elseif (Enum <= 98) then
if (Enum <= 91) then
if (Enum <= 87) then
if (Enum <= 85) then
Stk[Inst[2]] = Stk[Inst[3]] % Stk[Inst[4]];
elseif (Enum == 86) then
local A = Inst[2];
do
return Stk[A](Unpack(Stk, A + 1, Inst[3]));
end
else
Stk[Inst[2]] = Stk[Inst[3]][Inst[4]];
end
elseif (Enum <= 89) then
if (Enum == 88) then
local NewProto = Proto[Inst[3]];
local NewUvals;
local Indexes = {};
NewUvals = Setmetatable({}, {__index=function(, Key)
local Val = Indexes[Key];
return Val[1][Val[2]];
end,__newindex=function(, Key, Value)
local Val = Indexes[Key];
Val[1][Val[2]] = Value;
end});
for Idx = 1, Inst[4] do
VIP = VIP + 1;
local Mvm = Instr[VIP];
if (Mvm[1] == 8) then
Indexes[Idx - 1] = {Stk,Mvm[3]};
else
Indexes[Idx - 1] = {Upvalues,Mvm[3]};
end
Lupvals[#Lupvals + 1] = Indexes;
end
Stk[Inst[2]] = Wrap(NewProto, NewUvals, Env);
else
local B = Stk[Inst[4]];
if not B then
VIP = VIP + 1;
else
Stk[Inst[2]] = B;
VIP = Inst[3];
end
end
elseif (Enum > 90) then
Stk[Inst[2]] = Env[Inst[3]];
else
Stk[Inst[2]] = not Stk[Inst[3]];
end
elseif (Enum <= 94) then
if (Enum <= 92) then
local A = Inst[2];
do
return Unpack(Stk, A, Top);
end
elseif (Enum == 93) then
Stk[Inst[2]] = Upvalues[Inst[3]];
else
local NewProto = Proto[Inst[3]];
local NewUvals;
local Indexes = {};
NewUvals = Setmetatable({}, {__index=function(, Key)
local Val = Indexes[Key];
return Val[1][Val[2]];
end,__newindex=function(, Key, Value)
local Val = Indexes[Key];
Val[1][Val[2]] = Value;
end});
for Idx = 1, Inst[4] do
VIP = VIP + 1;
local Mvm = Instr[VIP];
if (Mvm[1] == 8) then
Indexes[Idx - 1] = {Stk,Mvm[3]};
else
Indexes[Idx - 1] = {Upvalues,Mvm[3]};
end
Lupvals[#Lupvals + 1] = Indexes;
end
Stk[Inst[2]] = Wrap(NewProto, NewUvals, Env);
end
elseif (Enum <= 96) then
if (Enum == 95) then
local A = Inst[2];
local B = Stk[Inst[3]];
Stk[A + 1] = B;
Stk[A] = B[Inst[4]];
elseif (Stk[Inst[2]] ~= Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum > 97) then
Stk[Inst[2]] = Stk[Inst[3]] + Stk[Inst[4]];
elseif (Stk[Inst[2]] < Stk[Inst[4]]) then
VIP = VIP + 1;
else
VIP = Inst[3];
end
elseif (Enum <= 105) then
if (Enum <= 101) then
if (Enum <= 99) then
VIP = Inst[3];
elseif (Enum > 100) then
local A = Inst[2];
local Cls = {};
for Idx = 1, #Lupvals do
local List = Lupvals[Idx];
for Idz = 0, #List do
local Upv = List[Idz];
local NStk = Upv[1];
local DIP = Upv[2];
if ((NStk == Stk) and (DIP >= A)) then
Cls[DIP] = NStk[DIP];
Upv[1] = Cls;
end
end
end
else
local A = Inst[2];
local T = Stk[A];
local B = Inst[3];
for Idx = 1, B do
T[Idx] = Stk[A + Idx];
end
end
elseif (Enum <= 103) then
if (Enum == 102) then
local A = Inst[2];
local T = Stk[A];
local B = Inst[3];
for Idx = 1, B do
T[Idx] = Stk[A + Idx];
end
else
Stk[Inst[2]] = -Stk[Inst[3]];
end
elseif (Enum > 104) then
Stk[Inst[2]] = Stk[Inst[3]] / Inst[4];
else
local A = Inst[2];
Stk[A](Stk[A + 1]);
end
elseif (Enum <= 109) then
if (Enum <= 107) then
if (Enum == 106) then
Stk[Inst[2]] = {};
else
local A = Inst[2];
Stk[A] = StkA;
end
elseif (Enum == 108) then
local A = Inst[2];
do
return Unpack(Stk, A, A + Inst[3]);
end
else
Stk[Inst[2]] = Stk[Inst[3]][Inst[4]];
end
elseif (Enum <= 111) then
if (Enum > 110) then
local A = Inst[2];
Stk[A] = Stk[A](Unpack(Stk, A + 1, Inst[3]));
else
Stk[Inst[2]][Inst[3]] = Inst[4];
end
elseif (Enum == 112) then
Stk[Inst[2]] = Wrap(Proto[Inst[3]], nil, Env);
else
local A = Inst[2];
do
return Stk[A](Unpack(Stk, A + 1, Inst[3]));
end
end
VIP = VIP + 1;
end
end;
end
return Wrap(Deserialize(), {}, vmenv)(...);
end
return VMCall("LOL!563Q0003043Q0067616D65030A3Q004765745365727669636503073Q00506C6179657273030A3Q0052756E5365727669636503093Q00776F726B7370616365030D3Q0043752Q72656E7443616D657261030B3Q004C6F63616C506C6179657203063Q00436F6C6F723303073Q0066726F6D524742025Q00E06F40028Q00025Q00406540026Q00F03F03063Q0043454E5445522Q033Q00544F5003063Q00424F2Q544F4D03083Q00496E7374616E63652Q033Q006E657703093Q005363722Q656E47756903043Q004E616D6503063Q00455350477569030C3Q0052657365744F6E537061776E010003063Q00506172656E74030C3Q0057616974466F724368696C6403093Q00506C6179657247756903063Q00697061697273030A3Q00476574506C617965727303093Q0043686172616374657203053Q007461626C6503063Q00696E73657274030B3Q00506C61796572412Q64656403073Q00436F2Q6E656374030D3Q0052656E6465725374652Q70656403053Q004672616D6503043Q0053697A6503053Q005544696D32030A3Q0066726F6D4F2Q66736574026Q006E40025Q0080764003083Q00506F736974696F6E03093Q0066726F6D5363616C65026Q33C33F026Q66D63F03103Q004261636B67726F756E64436F6C6F7233026Q003E40030F3Q00426F7264657253697A65506978656C03063Q004163746976652Q0103093Q004472612Q6761626C6503083Q005549436F726E6572030C3Q00436F726E657252616469757303043Q005544696D026Q002440026Q00444003163Q004261636B67726F756E645472616E73706172656E637903093Q00546578744C6162656C026Q0044C003043Q005465787403083Q00455350204D454E55030A3Q0054657874436F6C6F723303043Q00466F6E7403043Q00456E756D030E3Q00536F7572636553616E73426F6C6403083Q005465787453697A65026Q003440030E3Q005465787458416C69676E6D656E7403043Q004C656674030A3Q005465787442752Q746F6E025Q008041C0026Q00144003013Q002D025Q00804640026Q00184003073Q004553503A204F4E030B3Q00545241434552533A204F4E026Q004E4003133Q00545241434552204D4F44453A2043454E544552025Q00805B4003053Q00434F4C4F52026Q00644003073Q00444953434F5244025Q00406A4003043Q0051554954025Q0040704003113Q004D6F75736542752Q746F6E31436C69636B0070012Q00123D3Q00013Q00204C5Q0002001227000200034Q006F3Q0002000200123D000100013Q00204C000100010002001227000300044Q006F00010003000200123D000200053Q00205700020002000600205700033Q00072Q002C000400014Q002C000500014Q002C000600014Q006A000700043Q00123D000800083Q0020570008000800090012270009000A3Q001227000A000B3Q001227000B000B4Q006F0008000B000200123D000900083Q002057000900090009001227000A000B3Q001227000B000A3Q001227000C000B4Q006F0009000C000200123D000A00083Q002057000A000A0009001227000B000B3Q001227000C000C3Q001227000D000A4Q006F000A000D000200123D000B00083Q002057000B000B0009001227000C000A3Q001227000D000A3Q001227000E000B4Q006F000B000E000200123D000C00083Q002057000C000C0009001227000D000A3Q001227000E000B3Q001227000F000A4Q0003000C000F4Q000200073Q00010012270008000D4Q003B0009000700082Q006A000A00033Q001227000B000E3Q001227000C000F3Q001227000D00104Q0064000A00030001001227000B000D4Q003B000C000A000B2Q006A000D6Q006A000E5Q00123D000F00113Q002057000F000F0012001227001000134Q003A000F0002000200306E000F0014001500306E000F0016001700204C0010000300190012270012001A4Q006F001000120002001019000F0018001000065800103Q000100022Q00083Q00024Q00083Q000C3Q00065800110001000100032Q00083Q00044Q00083Q00064Q00083Q00093Q00021A001200023Q00065800130003000100022Q00083Q000D4Q00083Q00093Q00065800140004000100012Q00083Q000D3Q00123D0015001B3Q00204C00163Q001C2Q0012001600174Q002300153Q00170004633Q005D00010006310019005D000100030004633Q005D0001002057001A0019001D000643001A005D00013Q0004633Q005D00012Q003E001A00113Q002057001B0019001D2Q0068001A0002000100060B00150055000100020004633Q0055000100123D0015001E3Q00205700150015001F2Q003E0016000E3Q00205700173Q002000204C00170017002100065800190005000100022Q00083Q000E4Q00083Q00114Q0003001700194Q004400153Q000100123D0015001E3Q00205700150015001F2Q003E0016000E3Q00205700170001002200204C001700170021000658001900060001000D2Q00083Q00064Q00083Q00024Q00083Q00104Q00088Q00083Q00034Q00083Q00044Q00083Q00114Q00083Q00054Q00083Q00134Q00083Q000D4Q00083Q00094Q00083Q00144Q00083Q00124Q0003001700194Q004400153Q000100065800150007000100082Q00083Q00064Q00083Q00044Q00083Q00054Q00088Q00083Q00124Q00083Q00144Q00083Q000E4Q00083Q000F3Q00123D001600113Q002057001600160012001227001700234Q003E0018000F4Q006F00160018000200123D001700253Q002057001700170026001227001800273Q001227001900284Q006F00170019000200101900160024001700123D001700253Q00205700170017002A0012270018002B3Q0012270019002C4Q006F00170019000200101900160029001700123D001700083Q0020570017001700090012270018002E3Q0012270019002E3Q001227001A002E4Q006F0017001A00020010190016002D001700306E0016002F000B00306E00160030003100306E00160032003100123D001700113Q0020570017001